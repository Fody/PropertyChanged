using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

#pragma warning disable CS0067
static class SourceGeneratorEngine
{
    static readonly SymbolDisplayFormat namespaceDisplayFormat = new(SymbolDisplayGlobalNamespaceStyle.Omitted, SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces);

    const string sourceFileHintName = "PropertyChanged.g.cs";

    public static void GenerateSource(SourceProductionContext context, Configuration configuration, ImmutableArray<ClassContext> classes)
    {
        if (configuration.IsDisabled)
        {
            context.AddSource(sourceFileHintName, @"// Source generator is disabled by configuration.");
            return;
        }

        var eventInvokerName = configuration.EventInvokerName?.Trim().NullIfEmpty() ?? "OnPropertyChanged";

        var codeBuilder = new CodeBuilder();

        try
        {
            codeBuilder
                .Add("// <auto-generated/>")
                .Add("#nullable enable")
                .Add("#pragma warning disable CS0067")
                .Add("#pragma warning disable CS8019")
                .Add("using System.ComponentModel;")
                .Add("using System.Runtime.CompilerServices;");

            var classesByNamespace = classes
                .GroupBy(item => item.TypeSymbol?.ContainingNamespace?.ToDisplayString(namespaceDisplayFormat));

            foreach (var group in classesByNamespace)
                using (codeBuilder.AddBlock("namespace {0}", group.Key))
                {
                    foreach (var item in group)
                    {
                        var typeSymbol = item.TypeSymbol;
                        var classDeclaration = item.SyntaxDeclaration;

                        var isSealed = classDeclaration.Modifiers.Any(token => token.IsKind(SyntaxKind.SealedKeyword));
                        var hasBase = classDeclaration.BaseList.GetInterfaceTypeCandidates().Any();

                        var baseDefinition = hasBase ? string.Empty : " : INotifyPropertyChanged";

                        using (codeBuilder.AddBlock($"partial class {typeSymbol.Name}{baseDefinition}"))
                        {
                            codeBuilder.Add("public event PropertyChangedEventHandler? PropertyChanged;");

                            var modifiers1 = isSealed ? "private" : "protected";

                            using (codeBuilder.AddBlock($"{modifiers1} void {eventInvokerName}([CallerMemberName] string? propertyName = null)"))
                            {
                                if (isSealed)
                                {
                                    codeBuilder.Add("PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));");
                                }
                                else
                                {
                                    codeBuilder.Add("OnPropertyChanged(new PropertyChangedEventArgs(propertyName));");
                                }
                            }

                            var modifiers2 = isSealed ? "private" : "protected virtual";

                            using (codeBuilder.AddBlock($"{modifiers2} void {eventInvokerName}(PropertyChangedEventArgs eventArgs)"))
                            {
                                codeBuilder.Add("PropertyChanged?.Invoke(this, eventArgs);");
                            }
                        }
                    }
                }
        }
        catch (Exception ex)
        {
            codeBuilder.Add("/*");
            codeBuilder.Add($"GenerateSource failed: {ex}");
            codeBuilder.Add("*/");
        }

        context.AddSource(sourceFileHintName, codeBuilder.ToString());
    }
}